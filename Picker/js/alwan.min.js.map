{"version":3,"file":"js/alwan.min.js","mappings":"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","sources":["webpack://Alwan/webpack/universalModuleDefinition","webpack://Alwan/webpack/bootstrap","webpack://Alwan/webpack/runtime/define property getters","webpack://Alwan/webpack/runtime/hasOwnProperty shorthand","webpack://Alwan/./src/constants/classnames.js","webpack://Alwan/./src/constants/globals.js","webpack://Alwan/./src/core/events/binder.js","webpack://Alwan/./src/utils/object.js","webpack://Alwan/./src/utils/is.js","webpack://Alwan/./src/utils/dom.js","webpack://Alwan/./src/components/reference.js","webpack://Alwan/./src/utils/number.js","webpack://Alwan/./src/lib/popover.js","webpack://Alwan/./src/components/App.js","webpack://Alwan/./src/assets/svg.js","webpack://Alwan/./src/colors/stringify.js","webpack://Alwan/./src/colors/parser.js","webpack://Alwan/./src/components/Swatches.js","webpack://Alwan/./src/core/component.js","webpack://Alwan/./src/components/Palette.js","webpack://Alwan/./src/components/Utility.js","webpack://Alwan/./src/components/Sliders.js","webpack://Alwan/./src/components/Inputs.js","webpack://Alwan/./src/colors/converter.js","webpack://Alwan/./src/core/color.js","webpack://Alwan/./src/constants/defaults.js","webpack://Alwan/./src/index.js","webpack://Alwan/./src/core/events/dispatcher.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Alwan\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Alwan\"] = factory();\n\telse\n\t\troot[\"Alwan\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","export const ALWAN_CLASSNAME = 'alwan';\r\nexport const CONTAINER_CLASSNAME = `${ALWAN_CLASSNAME}__container`;\r\nexport const PALETTE_CLASSNAME = `${ALWAN_CLASSNAME}__palette`;\r\nexport const MARKER_CLASSNAME = `${ALWAN_CLASSNAME}__marker`;\r\nexport const PREVIEW_CLASSNAME = `${ALWAN_CLASSNAME}__preview`;\r\nexport const BUTTON_CLASSNAME = `${ALWAN_CLASSNAME}__button`;\r\nexport const COPY_BUTTON_CLASSNAME = `${ALWAN_CLASSNAME}__copy-button`;\r\nexport const SLIDER_CLASSNAME = `${ALWAN_CLASSNAME}__slider`;\r\nexport const SLIDERS_CLASSNAME = `${ALWAN_CLASSNAME}__sliders`;\r\nexport const HUE_SLIDER_CLASSNAME = `${ALWAN_CLASSNAME}__slider--hue`;\r\nexport const ALPHA_SLIDER_CLASSNAME = `${ALWAN_CLASSNAME}__slider--alpha`;\r\nexport const INPUT_CLASSNAME = `${ALWAN_CLASSNAME}__input`;\r\nexport const INPUTS_CLASSNAME = `${ALWAN_CLASSNAME}__inputs`;\r\nexport const SWATCH_CLASSNAME = `${ALWAN_CLASSNAME}__swatch`;\r\nexport const SWATCHES_CLASSNAME = `${ALWAN_CLASSNAME}__swatches`;\r\nexport const PRESET_BUTTON_CLASSNAME = `${ALWAN_CLASSNAME}__preset-button`;\r\nexport const BACKDROP_CLASSNAME = `${ALWAN_CLASSNAME}__backdrop`;\r\nexport const COLLAPSE_BUTTON_CLASSNAME = `${ALWAN_CLASSNAME}__toggle-button`;\r\n\r\nexport const POPUP_CLASSNAME = `${ALWAN_CLASSNAME}--popup`;\r\nexport const OPEN_CLASSNAME = `${ALWAN_CLASSNAME}--open`;\r\nexport const COLLAPSE_CLASSNAME = `${ALWAN_CLASSNAME}--collapse`;","export const ROOT = document;\r\nexport const DOC_ELEMENT = ROOT.documentElement;\r\n\r\nexport const DEFAULT_COLOR = '#000';\r\n\r\nexport const BUTTON = 'button';\r\n\r\nexport const OPEN = 'open';\r\nexport const CLOSE = 'close';\r\nexport const COLOR = 'color';\r\nexport const CLICK = 'click';\r\nexport const POINTER_DOWN = 'pointerdown';\r\nexport const POINTER_MOVE = 'pointermove';\r\nexport const POINTER_UP = 'pointerup';\r\nexport const SCROLL = 'scroll';\r\nexport const RESIZE = 'resize';\r\nexport const KEY_DOWN = 'keydown';\r\nexport const INPUT = 'input';\r\nexport const CHANGE = 'change';\r\nexport const BLUR = 'blur';\r\nexport const FOCUS_IN = 'focusin';\r\nexport const MOUSE_OUT = 'mouseout';\r\n\r\nexport const HEX_FORMAT = 'hex';\r\nexport const RGB_FORMAT = 'rgb';\r\nexport const HSL_FORMAT = 'hsl';\r\n\r\nexport const TAB = 'Tab';\r\nexport const ESCAPE = 'Escape';\r\n\r\n// Picker supported color formats.\r\nexport const COLOR_FORMATS = [HEX_FORMAT, RGB_FORMAT, HSL_FORMAT];\r\n\r\n// Element insert positions.\r\nexport const INSERT_BEFORE_FIRST_CHILD = 'afterbegin';\r\nexport const INSERT_AFTER = 'afterend';\r\nexport const INSERT_AFTER_LAST_CHILD = 'beforeend';\r\n\r\n/**\r\n * Horizontal movement using the keyboard arrow keys.\r\n */\r\nexport const KEYBOARD_X = {\r\n    ArrowRight: 1,\r\n    ArrowLeft: -1\r\n};\r\n\r\n/**\r\n * Vertical movement using the keyboard arrow keys.\r\n */\r\nexport const KEYBOARD_Y = {\r\n    ArrowDown: 1,\r\n    ArrowUp: -1\r\n};","/**\r\n * Attach an event listener to an element.\r\n *\r\n * @param {EventTarget} target - Event target.\r\n * @param {string} event - Event type.\r\n * @param {EventListenerOrEventListenerObject} listener - Event listener.\r\n */\r\nexport const addEvent = (target, event, listener) => {\r\n    target.addEventListener(event, listener);\r\n}\r\n\r\n/**\r\n * Removes event listener from an element.\r\n *\r\n * @param {EventTarget} target - Event target.\r\n * @param {string} event - Event type.\r\n * @param {EventListenerOrEventListenerObject} listener - Event listener.\r\n */\r\nexport const removeEvent = (target, event, listener) => {\r\n    target.removeEventListener(event, listener);\r\n}\r\n\r\n","export const { keys, assign: merge, setPrototypeOf, prototype } = Object;\r\nexport const { from: toArray, isArray } = Array;\r\n\r\n/**\r\n * Iterate in an object.\r\n * If any callback function return a value different then null or undefined,\r\n * then stop iteration and return that value.\r\n *\r\n * @param {Object} object - Any object.\r\n * @param {Function} fn - A Callback function.\r\n * @returns {any}\r\n */\r\nexport const objectIterator = (object, fn) => {\r\n    let props = keys(object);\r\n    for (const prop of props) {\r\n       fn(object[prop], prop);\r\n    }\r\n}","/**\r\n * Checks if a value is a string.\r\n *\r\n * @param {unknown} value - Value to check.\r\n * @returns {boolean} Whether value is a string.\r\n */\r\nexport const isString = (value) => {\r\n    return typeof value === 'string';\r\n}\r\n\r\n/**\r\n * Checks if a value is not undefined or null.\r\n *\r\n * @param {Any} value - Value.\r\n * @returns {Boolean}\r\n */\r\nexport const isset = value => value != null;\r\n\r\n\r\n/**\r\n * Checks if an instance is able to be toggled.\r\n *\r\n * @param {object} param0 - Alwan instance config.\r\n * @returns {boolean}\r\n */\r\nexport const isTogglable = ({ shared, toggle }) => shared || toggle;","import { BUTTON_CLASSNAME, CONTAINER_CLASSNAME, SLIDER_CLASSNAME } from \"../constants/classnames\";\r\nimport { BUTTON, DOC_ELEMENT, INPUT, INSERT_AFTER_LAST_CHILD, ROOT } from \"../constants/globals\";\r\nimport { merge, objectIterator } from \"./object\";\r\nimport { isString, isset } from \"./is\";\r\n\r\n/**\r\n * Gets the body element.\r\n *\r\n * @returns Document's body.\r\n */\r\nexport const bodyElement = () => ROOT.body;\r\n\r\n/**\r\n * Gets elements.\r\n *\r\n * @param {string|Element} reference - CSS selector or a HTML element.\r\n * @param {Document|Element} context - Element to search from.\r\n * @param {boolean} all - Select all elements.\r\n * @returns {null|Element|NodeList}\r\n */\r\nexport const getElement = (reference, context = bodyElement(), all = false) => {\r\n    if (isString(reference) && reference.trim()) {\r\n        return context[`querySelector${ all ? 'All' : ''}`](reference);\r\n    }\r\n    // Reference must be an element in the page.\r\n    if (reference instanceof Element && bodyElement().contains(reference) && reference !== bodyElement()) {\r\n        return reference;\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Inserts an element relative to another element (target element).\r\n *\r\n * @param {Element} element - The element to be inserted.\r\n * @param {Element} targetElement - Element used as a reference.\r\n * @param {InsertPosition} where - Insert position relative to the targetElement.\r\n * @returns {Element|undefined} - The inserted element.\r\n */\r\nexport const insertElement = (element, targetElement, where = INSERT_AFTER_LAST_CHILD) => {\r\n    if (element && targetElement) {\r\n        targetElement.insertAdjacentElement(where, element);\r\n    }\r\n}\r\n\r\n/**\r\n * Sets element's inner html.\r\n *\r\n * @param {Element} element - An HTML element.\r\n * @param {string} html - HTML string.\r\n */\r\nexport const setHTML = (element, html) => {\r\n    element.innerHTML = html;\r\n}\r\n\r\n/**\r\n * Creates a new HTML Element.\r\n *\r\n * @param {string} tagName - Element tag name.\r\n * @param {string} className - Element class name.\r\n * @param {Element} targetElement - Insert the new element relative to this element using position.\r\n * @param {object} details - Element details (attributes + Initial content).\r\n * @param {InsertPosition} insertPosition - Insert position.\r\n * @returns {Element} The new created element.\r\n */\r\nexport const createElement = (tagName, className, targetElement, details, insertPosition) => {\r\n    const element = ROOT.createElement(tagName || 'div');\r\n\r\n    if (className) {\r\n        element.className = className;\r\n    }\r\n\r\n    objectIterator(details || {}, (value, name) => {\r\n        if (name === 'html') {\r\n            setHTML(element, value);\r\n        } else if (value) {\r\n            element.setAttribute(name, value);\r\n        }\r\n    });\r\n\r\n    if (targetElement) {\r\n        insertElement(element, targetElement, insertPosition);\r\n    }\r\n\r\n    return element;\r\n}\r\n\r\n/**\r\n * Gets element's bounding rect.\r\n *\r\n * @param {Document|Element} element - Element.\r\n * @returns {DOMRect}\r\n */\r\nexport const getBounds = (element) => {\r\n    let x, y, width, height, right, bottom;\r\n\r\n    if (element === ROOT) {\r\n        x = y = 0;\r\n        width = right = DOC_ELEMENT.clientWidth;\r\n        height = bottom = DOC_ELEMENT.clientHeight;\r\n    } else {\r\n        ({ x, y, width, height, right, bottom } = element.getBoundingClientRect());\r\n    }\r\n\r\n    return [x, y, width, height, right, bottom];\r\n}\r\n\r\n/**\r\n * Replaces an element in the DOM with another element.\r\n *\r\n * @param {Element} element - Element to replace another element.\r\n * @param {Element} replacement - Element to be replaced by the newElement.\r\n * @returns {Element} The new element.\r\n */\r\nexport const replaceElement = (element, replacement) => {\r\n    element.replaceWith(replacement);\r\n    return replacement;\r\n}\r\n\r\n/**\r\n * Remove element from the document.\r\n *\r\n * @param {Element} element - Element to remove.\r\n */\r\nexport const removeElement = (element) => {\r\n    if (element) {\r\n        element.remove();\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Gets overflow ancestor of an element (body element is not included).\r\n *\r\n * @param {Element} element - Element.\r\n * @param {array<Element|Document>} ancestors - Array of overflow ancestors.\r\n * @returns {array<Element|Document>}\r\n */\r\nexport const getOverflowAncestors = (element, ancestors = [ROOT]) => {\r\n\r\n    if (element) {\r\n        element = element.parentElement;\r\n    }\r\n\r\n    if (! element || element === bodyElement()) {\r\n        return ancestors;\r\n    }\r\n\r\n    if (/auto|scroll|overflow|clip|hidden/.test(getComputedStyle(element).overflow)) {\r\n        ancestors.push(element);\r\n    }\r\n\r\n    return getOverflowAncestors(element, ancestors);\r\n}\r\n\r\n/**\r\n * Sets a CSS custom property if value is not undefined, otherwise returns the value of,\r\n * the given property.\r\n *\r\n * @param {HTMLElement} element  - Element to set/get its custom property.\r\n * @param {string} property - Custom property name.\r\n * @param {string | undefined} value    - Custom property value.\r\n */\r\nexport const customProperty = (element, property, value) => {\r\n\r\n    if (element) {\r\n        return element.style[isset(value) ? 'setProperty' : 'getPropertyValue']('--alwan-' + property, value);\r\n    }\r\n\r\n    return '';\r\n}\r\n\r\n\r\n/**\r\n * Adds/Removes a class to/from an based on a boolean variable.\r\n *\r\n * @param {Element} element - Element.\r\n * @param {string|string[]} tokens - Class name or array of classes.\r\n * @param {boolean} toggler - Whether to add (true) or remove a class.\r\n */\r\nexport const toggleClassName = (element, tokens, toggler) => {\r\n\r\n    if (isString(tokens)) {\r\n        tokens = [tokens];\r\n    }\r\n\r\n    tokens.forEach(token => {\r\n        if (token) {\r\n            element.classList.toggle(token, toggler);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Creates a button Element.\r\n *\r\n * @param {string} className - Class.\r\n * @param {Element} targetElement - TargetElement.\r\n * @param {object} details - Button details.\r\n * @param {string} insertPosition - Button insert position.\r\n * @returns {Element} A button.\r\n */\r\nexport const createButton = (className, targetElement, details, insertPosition) => {\r\n    return createElement(BUTTON, BUTTON_CLASSNAME + ' ' + className, targetElement, merge({ type: BUTTON }, details), insertPosition);\r\n}\r\n\r\n/**\r\n * Translates an element.\r\n *\r\n * @param {Element} element - Element to translate.\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n */\r\nexport const translate = (element, x, y) => {\r\n    element.style.transform = `translate(${x}px,${y}px)`;\r\n}\r\n\r\n/**\r\n * Creates a slider.\r\n *\r\n * @param {string} className - CSS class.\r\n * @param {Element} parent - Slider parent.\r\n * @param {number} max - Max property.\r\n * @param {number} step - Step property.\r\n * @returns {HTMLInputElement} - Slider.\r\n */\r\nexport const createSlider = (className, parent, max, step) => {\r\n    return createElement(INPUT, SLIDER_CLASSNAME + ' ' + className, parent, { type: 'range', max, step });\r\n}\r\n\r\n/**\r\n * Creates a container element.\r\n *\r\n * @param {Element} targetElement - Element used as a reference.\r\n * @param {InsertPosition | undefined} where - Insert position relative to the targetElement\r\n */\r\nexport const createContainer = (targetElement, where) => {\r\n    return createElement('', CONTAINER_CLASSNAME, targetElement, {}, where);\r\n}","import { PRESET_BUTTON_CLASSNAME } from \"../constants/classnames\";\r\nimport { CLICK } from \"../constants/globals\";\r\nimport { addEvent, removeEvent } from \"../core/events/binder\";\r\nimport { bodyElement, createButton, removeElement, replaceElement, toggleClassName } from \"../utils/dom\";\r\nimport { isString, isTogglable, isset } from \"../utils/is\";\r\n\r\n/**\r\n * Creates an element that controls (open/close) the color picker.\r\n *\r\n * @param {string|Element} reference - User Reference.\r\n * @param {Alwan} param1 - Alwan instance.\r\n * @returns {object} - ReferenceElement control.\r\n */\r\nexport const Reference = (userReference, alwan) => {\r\n\r\n    /**\r\n     * Reference element.\r\n     *\r\n     * @type {Element | HTMLButtonElement | null}\r\n     */\r\n    let element = userReference || createButton(PRESET_BUTTON_CLASSNAME, bodyElement());\r\n\r\n    /**\r\n     * Preset button user set classes.\r\n     */\r\n    let buttonClasses = [];\r\n\r\n    /**\r\n     * Handles mouse click.\r\n     */\r\n    let handleClick = () => {\r\n        alwan.toggle();\r\n    }\r\n\r\n    /**\r\n     * Reference API.\r\n     */\r\n    return {\r\n        /**\r\n         * Returns the reference element.\r\n         *\r\n         * @returns {Element}\r\n         */\r\n        _el: () => element,\r\n\r\n        /**\r\n         * Initialize Reference element.\r\n         *\r\n         * @param {object} param - Alwan options.\r\n         */\r\n        _init({ preset, classname }) {\r\n            // userReference === element means preset button is not set.\r\n            if (userReference && preset !== (userReference !== element)) {\r\n                if (preset) {\r\n                    // Replace user reference with a preset button.\r\n                    element = replaceElement(userReference, createButton(PRESET_BUTTON_CLASSNAME, null, { id: userReference.id }));\r\n                } else {\r\n                    // Replace preset button with the user reference.\r\n                    element = replaceElement(element, userReference);\r\n                }\r\n            }\r\n\r\n            addEvent(element, CLICK, handleClick);\r\n\r\n            // Add custom classes to the preset button.\r\n            if ((! userReference || preset) && isString(classname)) {\r\n                // Remove previously add classes.\r\n                toggleClassName(element, buttonClasses, false);\r\n                buttonClasses = classname.split(/\\s+/);\r\n                // Add the new classname.\r\n                toggleClassName(element, buttonClasses, true);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Disables/Enables Picker instance.\r\n         *\r\n         * @param {boolean} disabled - Disable/Enable.\r\n         */\r\n        _setDisabled(disabled) {\r\n            if (isset(disabled)) {\r\n                const { config, _components } = alwan;\r\n                const toggler = _components._app._toggle;\r\n\r\n                config.disabled = element.disabled = !! disabled;\r\n\r\n                if (disabled) {\r\n                    toggler(alwan, false, true);\r\n                } else if (! isTogglable(config)) {\r\n                    toggler(alwan, true, true);\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Destroy reference component.\r\n         */\r\n        _destroy() {\r\n            if (userReference) {\r\n                this._init({ preset: false });\r\n                removeEvent(element, CLICK, handleClick);\r\n            } else {\r\n                element = removeElement(element);\r\n            }\r\n        }\r\n    }\r\n}","export const { parseFloat: float, parseInt: int, isFinite: isNumeric } = Number;\r\nexport const { min, max, abs, round, PI } = Math;\r\n\r\n/**\r\n * Keeps a number in a range.\r\n *\r\n * @param {number} number - A number to keep it between two numbers.\r\n * @param {number} upperBound - Max.\r\n * @param {number} lowerBound - Min.\r\n * @returns {number}\r\n */\r\nexport const boundNumber = (number, upperBound = 100, lowerBound = 0) => {\r\n    return min(max(number, lowerBound), upperBound);\r\n}\r\n\r\n/**\r\n * Angle value in degrees, it must be between 0 and 360.\r\n *\r\n * @param {number} angle - Angle.\r\n * @returns {Number}\r\n */\r\nexport const normalizeAngle = angle => {\r\n    return (round(angle) % 360 + 360) % 360;\r\n}","import { KEY_DOWN, POINTER_DOWN, RESIZE, ROOT, SCROLL } from \"../constants/globals\";\r\nimport { addEvent, removeEvent } from \"../core/events/binder\";\r\nimport { getBounds, getOverflowAncestors, translate } from \"../utils/dom\";\r\nimport { abs, float, isNumeric, round } from \"../utils/number\";\r\nimport { isString, isset } from \"../utils/is\";\r\n\r\n// getBounds function array.\r\nconst LEFT = 0; // Also the x coordinate.\r\nconst TOP = 1; // Also the y coordinate.\r\nconst RIGHT = 4;\r\nconst BOTTOM = 5;\r\n\r\nconst START = 0;\r\nconst CENTER = 1;\r\nconst END = 2;\r\n\r\n/**\r\n * Sides to fallback to for each side.\r\n */\r\nconst fallbackSides = {\r\n    top: [TOP, BOTTOM, RIGHT, LEFT],\r\n    bottom: [BOTTOM, TOP, RIGHT, LEFT],\r\n    right: [RIGHT, LEFT, TOP, BOTTOM],\r\n    left: [LEFT, RIGHT, TOP, BOTTOM],\r\n};\r\n\r\n/**\r\n * Alignments to fallback to for each alignment.\r\n */\r\nconst fallbackAlignments = {\r\n    start: [START, CENTER, END],\r\n    center: [CENTER, START, END],\r\n    end: [END, CENTER, START],\r\n};\r\n\r\n/**\r\n * Creates a Popover instance.\r\n *\r\n * @param {Element} target - Popover target.\r\n * @param {HTMLElement} container - Popover container.\r\n * @param {object} param2 - Popover options.\r\n * @param {Function} autoUpdate - Auto update callback.\r\n * @param {Function} accessibility - Popover accessibility callback.\r\n */\r\nexport const createPopover = (target, container, { _margin, _position }, autoUpdate, popoverAccessibility) => {\r\n    if (isString(_margin)) {\r\n        _margin = float(_margin);\r\n    }\r\n    const margin = isNumeric(_margin) ? _margin : 0;\r\n    const [side, alignment] = isString(_position) ? _position.split('-') : [];\r\n    const sidesFlipOrder = fallbackSides[side] || fallbackSides.bottom;\r\n    const alignmentsFlipOrder = fallbackAlignments[alignment] || fallbackAlignments.center;\r\n    const overflowAncestors = getOverflowAncestors(target);\r\n\r\n    /**\r\n     * Updates the container's position.\r\n     */\r\n    const _update = () => {\r\n        const visualViewport = getBounds(ROOT);\r\n        const targetBounds = getBounds(target);\r\n        const containerBounds = getBounds(container);\r\n        const coordinates = [];\r\n\r\n        /**\r\n         * Check sides.\r\n         */\r\n        sidesFlipOrder.some((side) => {\r\n            // Get axis of the side.\r\n            // x (0) if side is LEFT (1) or RIGHT (4).\r\n            // y (1) if side is TOP (0) or BOTTOM (5).\r\n            let axis = side % 2;\r\n            // Viewport side.\r\n            const domSide = visualViewport[side];\r\n            // Target element coordinate.\r\n            const targetSide = targetBounds[side];\r\n            // Space required for the container.\r\n            // Adding 2 to the axis index gives the dimension based on the axis,\r\n            // x => width and y => height.\r\n            const requiredSpace = margin + containerBounds[axis + 2];\r\n\r\n            if (requiredSpace <= abs(domSide - targetSide)) {\r\n                // Calculate coordinate to set this side.\r\n                // side <= 1 means side is either TOP or LEFT.\r\n                // otherwise it's BOTTOM or RIGHT.\r\n                coordinates[axis] = targetSide + (side <= 1 ? -requiredSpace : margin);\r\n                // Reverse the axis for the alignments.\r\n                // x (0) => y (1)\r\n                // y (1) => x (0)\r\n                axis = (axis + 1) % 2;\r\n                const containerDimension = containerBounds[axis + 2];\r\n                // Lower bound is either the TOP | LEFT coordinate and,\r\n                // the Upper bound is either the BOTTOM | RIGHT coordinates of the target element.\r\n                // depends on the axis.\r\n                const targetLowerBound = targetBounds[axis];\r\n                const targetUpperBound = targetBounds[axis + 4];\r\n                // Distance between the document upper bound (BOTTOM or RIGHT) and,\r\n                // the target element lower bound (TOP or LEFT).\r\n                const upperBoundDistance = visualViewport[axis + 4] - targetLowerBound;\r\n                // Offset between the container and the reference element.\r\n                const offset = (containerDimension + targetBounds[axis + 2]) / 2;\r\n\r\n                /**\r\n                 * Check alignments, only if the container is attached to one side.\r\n                 */\r\n                alignmentsFlipOrder.some((alignment) => {\r\n                    // Check space, if it's available then align the container.\r\n                    if (alignment === START && containerDimension <= upperBoundDistance) {\r\n                        coordinates[axis] = targetLowerBound;\r\n                        return true;\r\n                    }\r\n                    if (\r\n                        alignment === CENTER &&\r\n                        offset <= targetUpperBound &&\r\n                        offset <= upperBoundDistance\r\n                    ) {\r\n                        coordinates[axis] = targetUpperBound - offset;\r\n                        return true;\r\n                    }\r\n                    if (alignment === END && containerDimension <= targetUpperBound) {\r\n                        coordinates[axis] = targetUpperBound - containerDimension;\r\n                        return true;\r\n                    }\r\n                    return false;\r\n                });\r\n\r\n                return true;\r\n            }\r\n        });\r\n\r\n        // If there is no space to position the popover in all sides,\r\n        // then center the popover in the screen.\r\n        // If the popover is attached to one side but there is no space,\r\n        // for the alignment then center it horizontally/vertically depends on the side.\r\n        translate(\r\n            container,\r\n            ...(coordinates.map((value, axis) =>\r\n                round(\r\n                    isset(value) ?\r\n                    value\r\n                    : (visualViewport[axis + 4] - containerBounds[axis + 2]) / 2\r\n                )\r\n            ))\r\n        );\r\n    };\r\n\r\n    /**\r\n     * Checks if target element is visible is the viewport.\r\n     */\r\n    const isVisible = () => {\r\n        return overflowAncestors.every((ancestor) => {\r\n            const [x, y, , , right, bottom] = getBounds(target);\r\n            const [ancestorX, ancestorY, , , ancestorRight, ancestorBottom] = getBounds(ancestor);\r\n\r\n            return (\r\n                y < ancestorBottom && bottom > ancestorY && x < ancestorRight && right > ancestorX\r\n            );\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Target overflow ancestors onScroll and window onResize event handler.\r\n     */\r\n    const eventHandler = () => {\r\n        autoUpdate(_update, isVisible);\r\n    };\r\n\r\n    /**\r\n     * Attach/Detach popover event listeners.\r\n     *\r\n     * @param {Function} fn - A callback function that attach/Detach events listeners.\r\n     */\r\n    const popoverEvents = (fn) => {\r\n        overflowAncestors.forEach((ancestor) => {\r\n            fn(ancestor, SCROLL, eventHandler);\r\n        });\r\n        fn(window, RESIZE, eventHandler);\r\n        fn(ROOT, KEY_DOWN, popoverAccessibility);\r\n        fn(ROOT, POINTER_DOWN, popoverAccessibility);\r\n    };\r\n\r\n    // First update.\r\n    _update();\r\n    // Attach listeners.\r\n    popoverEvents(addEvent);\r\n\r\n    return {\r\n        _update,\r\n\r\n        /**\r\n         * Remove popover functionality.\r\n         */\r\n        _destroy() {\r\n            // Remove listeners.\r\n            popoverEvents(removeEvent);\r\n            container.style.transform = '';\r\n        }\r\n    }\r\n}","import { OPEN_CLASSNAME, POPUP_CLASSNAME } from \"../constants/classnames\";\r\nimport { CLOSE, ESCAPE, INSERT_AFTER, INSERT_AFTER_LAST_CHILD, OPEN, TAB} from \"../constants/globals\";\r\nimport { createPopover } from \"../lib/popover\";\r\nimport { getElement, insertElement, removeElement, toggleClassName } from \"../utils/dom\";\r\nimport { objectIterator, toArray } from \"../utils/object\";\r\nimport { isString, isTogglable, isset } from \"../utils/is\";\r\nimport { isShared } from \"../core/component\";\r\n\r\n/**\r\n * Creates App component and initialize components.\r\n *\r\n * @param {Element} root - Picker container.\r\n * @param {Alwan} alwan - Alwan instance.\r\n * @returns {object}\r\n */\r\nexport const App = (root, alwan) => {\r\n    /**\r\n     * Popper instance.\r\n     */\r\n    let popoverInstance = null;\r\n\r\n    /**\r\n     * Visibility state.\r\n     */\r\n    let isOpen = false;\r\n\r\n    /**\r\n     * Setup and Initialize other components.\r\n     *\r\n     * @param {object} options - Alwan options.\r\n     * @param {object} instance - Alwan instance.\r\n     */\r\n    const _setup = (options, instance = alwan) => {\r\n        alwan = instance;\r\n        const components = alwan._components;\r\n        const { theme, popover, target, position, margin, id } = options;\r\n        const refElement = alwan._reference._el();\r\n        const targetElement = getElement(target) || refElement;\r\n        const toggle = isTogglable(options);\r\n\r\n        if (isString(id) && ! isShared(components)) {\r\n            root.id = id;\r\n        }\r\n\r\n        // Initialize components.\r\n        objectIterator(components, ({ _init }) => {\r\n            if (_init) {\r\n                _init(options, alwan);\r\n            }\r\n        })\r\n\r\n        // Set theme (dark or light).\r\n        root.dataset.theme = theme;\r\n\r\n        // If toggle option changed to false, then open (show) the picker\r\n        if (! toggle) {\r\n            _toggle(alwan, true, true);\r\n        }\r\n\r\n        // Hide reference element if both toggle and popover options are set to false,\r\n        // and the components are not shared.\r\n        refElement.style.display = popover || toggle ? '' : 'none';\r\n\r\n        // Toggle popup class that makes the root's position fixed.\r\n        toggleClassName(root, POPUP_CLASSNAME, popover);\r\n\r\n        if (popoverInstance) {\r\n            popoverInstance._destroy();\r\n            popoverInstance = null;\r\n        }\r\n\r\n        if (popover) {\r\n            popoverInstance = createPopover(\r\n                targetElement,\r\n                root,\r\n                {\r\n                    _margin: margin,\r\n                    _position: position\r\n                },\r\n                autoUpdate,\r\n                popoverAccessibility\r\n            );\r\n        } else {\r\n            // If there is a target element then append the color picker widget in it,\r\n            // otherwise insert it after the reference element.\r\n            insertElement(\r\n                root,\r\n                targetElement,\r\n                targetElement === refElement ? INSERT_AFTER : INSERT_AFTER_LAST_CHILD\r\n            )\r\n        }\r\n\r\n        alwan._color._update({}, null, true);\r\n    }\r\n\r\n    /**\r\n     * Auto updates popover position and picker visibility.\r\n     *\r\n     * @param {Function} update - Popover position updater function.\r\n     * @param {Function} isInViewport - Checks if popover target element is visible in the viewport.\r\n     */\r\n    const autoUpdate = (update, isInViewport) => {\r\n        if (isOpen || ! isTogglable(alwan.config)) {\r\n            if (isInViewport()) {\r\n                if (isOpen) {\r\n                    // Update popover position if its target element is in the viewport,\r\n                    // and picker is open.\r\n                    update();\r\n\r\n                    if (alwan.config.closeOnScroll) {\r\n                        // Close picker when scrolling.\r\n                        _toggle(alwan, false);\r\n                    }\r\n                } else {\r\n                    // This is reachable only if toggle is false,\r\n                    // open picker if the popover target element becomes visible.\r\n                    _toggle(alwan, true, true);\r\n                }\r\n            } else {\r\n                // Force close picker if the target element is not in the viewport.\r\n                _toggle(alwan, false, true);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles keyboard accessibility.\r\n     *\r\n     * If picker is displayed as a popover then link the focus from the reference,\r\n     * to the picker focusable elements.\r\n     *\r\n     * @param {KeyboardEvent | PointerEvent} e - Event.\r\n     */\r\n    const popoverAccessibility = (e) => {\r\n        if (isOpen) {\r\n            let { target, key, shiftKey } = e;\r\n            let refElement = alwan._reference._el();\r\n            let focusableElements,\r\n                firstFocusableElement,\r\n                lastFocusableElement,\r\n                elementToFocusOn;\r\n\r\n            // Close picker if:\r\n            // - Escape key is pressed.\r\n            // - A pointerdown event happened outside the picker and not on the reference element\r\n            // or one of its labels (if it has any).\r\n            if (\r\n                key === ESCAPE ||\r\n                (target !== refElement && !root.contains(target) && ! toArray(refElement.labels || []).some((label) => label.contains(target)))\r\n            ) {\r\n                _toggle(alwan, false);\r\n            } else if (key === TAB) {\r\n                focusableElements = toArray(getElement('button,input,[tabindex]', root, true));\r\n                firstFocusableElement = focusableElements[0];\r\n                lastFocusableElement = focusableElements.pop();\r\n\r\n                if (target === refElement && !shiftKey) {\r\n                    // Pressing Tab while focusing on the reference element sends focus,\r\n                    // to the first element (palette) inside the picker container.\r\n                    elementToFocusOn = firstFocusableElement;\r\n                } else if ((shiftKey && target === firstFocusableElement) || (!shiftKey && target === lastFocusableElement)) {\r\n                    // Pressing Tab while focusing on the palette with the shift key or focussing on the last,\r\n                    // focusable element without shift key sends focus to the reference element (if it's focusable).\r\n                    elementToFocusOn = refElement;\r\n                }\r\n\r\n                if (elementToFocusOn) {\r\n                    e.preventDefault();\r\n                    elementToFocusOn.focus();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Toggles color picker visibility.\r\n     *\r\n     * @param {object} instance - Alwan instance.\r\n     * @param {boolean} state - True to open, false to close.\r\n     * @param {boolean} forced - Open/Close picker even if its disabled or the toggle option is set to false.\r\n     */\r\n    const _toggle = (instance, state, forced) => {\r\n        instance = instance || alwan;\r\n\r\n        const instanceConfig = instance.config;\r\n\r\n        if (! instanceConfig.disabled || forced) {\r\n\r\n            if (! isset(state)) {\r\n                // If the instance doesn't control the components.\r\n                // then close the instance that controls the components.\r\n                if (isOpen && instance !== alwan) {\r\n                    _toggle(alwan, false);\r\n                }\r\n\r\n                state = ! isOpen;\r\n            }\r\n\r\n            if (state !== isOpen && (isTogglable(instanceConfig) || forced)) {\r\n                if (state) {\r\n                    if (instance !== alwan) {\r\n                        // Set components to point to the new instance,\r\n                        // and update options.\r\n                        _setup(instanceConfig, instance);\r\n                    }\r\n\r\n                    // Update popover position before open.\r\n                    if (state) {\r\n                        _reposition();\r\n                    }\r\n                }\r\n\r\n                // Only the instance that controls the components,\r\n                // open/close the picker.\r\n                if (instance === alwan) {\r\n                    isOpen = state;\r\n                    toggleClassName(root, OPEN_CLASSNAME, state);\r\n                    alwan._events._dispatch(state ? OPEN : CLOSE, root);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the popover's position.\r\n     */\r\n    const _reposition = () => {\r\n        if (popoverInstance) {\r\n            popoverInstance._update();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets current picker state (opened or closed).\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    const _isOpen = () => {\r\n        return isOpen;\r\n    }\r\n\r\n    /**\r\n     * Destroy components and remove root element from the DOM.\r\n     */\r\n    const _destroy = () => {\r\n        if (popoverInstance) {\r\n            popoverInstance._destroy();\r\n        }\r\n        removeElement(root);\r\n    }\r\n\r\n    return {\r\n        _setup,\r\n        _reposition,\r\n        _toggle,\r\n        _isOpen,\r\n        _destroy\r\n    }\r\n}","export const clipboardSVG = `<svg width=\"18\" height=\"18\" viewBox=\"0 0 24 24\" aria-role=\"none\"><path d=\"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z\"></path></svg>`;\r\nexport const checkSVG = `<svg width=\"18\" height=\"18\" viewBox=\"0 0 24 24\" aria-role=\"none\"><path d=\"M9,20.42L2.79,14.21L5.62,11.38L9,14.77L18.88,4.88L21.71,7.71L9,20.42Z\"></path></svg>`;\r\nexport const switchInputsSVG = `<svg width=\"15\" height=\"15\" viewBox=\"0 0 20 20\" aria-role=\"none\"><path d=\"M10 1L5 8h10l-5-7zm0 18l5-7H5l5 7z\"></path></svg>`;\r\nexport const caretSVG = `<svg width=\"20\" height=\"20\" viewBox=\"0 0 24 24\" aria-role=\"none\"><path d=\"M6.984 14.016l5.016-5.016 5.016 5.016h-10.031z\"></path></svg>`;","import { RGB_FORMAT } from \"../constants/globals\";\r\n\r\n/**\r\n * Converts RGB or HSL color objects to string.\r\n *\r\n * @param {object} color - HSL or RGB color object.\r\n * @param {string} format - Color format (hex, rgb or hsl).\r\n * @returns {string} rgb or hsl string.\r\n */\r\nexport const stringify = (color, format) => {\r\n    let opacity = '';\r\n    let a = color.a;\r\n    let str = format;\r\n\r\n    if (a < 1) {\r\n        str += 'a';\r\n        opacity = ', ' + a;\r\n    }\r\n\r\n    if (format === RGB_FORMAT) {\r\n        return str + `(${color.r}, ${color.g}, ${color.b + opacity})`;\r\n    }\r\n\r\n    return str + `(${color.h}, ${color.s}%, ${color.l}%${opacity})`;\r\n}","import { DEFAULT_COLOR, HSL_FORMAT, RGB_FORMAT } from \"../constants/globals\";\r\nimport { createElement } from \"../utils/dom\";\r\nimport { float, isNumeric, normalizeAngle, boundNumber, PI, round, int } from \"../utils/number\";\r\nimport { isString } from \"../utils/is\";\r\nimport { stringify } from \"./stringify\";\r\n\r\nconst ctx = createElement('canvas').getContext('2d');\r\n\r\n/**\r\n * Regex.\r\n */\r\nconst HSL_REGEX = /^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(\\w*)?\\s*[\\s,]\\s*([+-]?\\d*\\.?\\d+)%?\\s*,?\\s*([+-]?\\d*\\.?\\d+)%?(?:\\s*[\\/,]\\s*([+-]?\\d*\\.?\\d+)(%)?)?\\s*\\)?$/;\r\nconst HEX_REGEX = /^#[0-9a-f]{6}$/i;\r\n/**\r\n * Used to convert non degrees angles to degrees.\r\n */\r\nconst ANGLE_COEFFICIENT_MAP = {\r\n    deg: 1,\r\n    turn: 360,\r\n    rad: 180 / PI,\r\n    grad: 0.9\r\n}\r\n\r\n/**\r\n * Parses any value into an RGB or HSL objects.\r\n * Invalid color values default to #000.\r\n *\r\n * @param {unknown} value - A value to parse.\r\n * @param {boolean} asString - Whether to return the result as a string or object.\r\n * @returns {object|string} - Parsed color as string or object.\r\n */\r\nexport const parseColor = (value = '', asString) => {\r\n\r\n    let color;\r\n    let format;\r\n    let str = '';\r\n\r\n    /**\r\n     * Validate Non string values, convert color objects into strings.\r\n     * Invalid values default to empty string.\r\n     */\r\n    if (! isString(value)) {\r\n        value = value || {};\r\n\r\n        format = [RGB_FORMAT, HSL_FORMAT].find(format => {\r\n            return format.split('').every(key => {\r\n                return isNumeric(float(value[key]));\r\n            });\r\n        });\r\n\r\n        if (format) {\r\n            str = stringify(value, format);\r\n        }\r\n    } else {\r\n        str = value.trim();\r\n    }\r\n\r\n    /**\r\n     * Parse strings\r\n     */\r\n    let [input, h, angle, s, l, a = 1, percentage] = HSL_REGEX.exec(str) || [];\r\n\r\n    // str is a hsl string.\r\n    if (input) {\r\n        /**\r\n         * Normalize values.\r\n         *\r\n         * The hue value is so often given in degrees, it can be given as a number, however\r\n         * it might has a unit 'turn', 'rad' (radians) or 'grad' (gradients),\r\n         * If the hue has a unit other than deg, then convert it to degrees.\r\n         */\r\n        color = {\r\n            h: normalizeAngle(h * (ANGLE_COEFFICIENT_MAP[angle] ? ANGLE_COEFFICIENT_MAP[angle] : 1)),\r\n            s: round(boundNumber(s)),\r\n            l: round(boundNumber(l)),\r\n            a: boundNumber(percentage ? a / 100 : a, 1)\r\n        }\r\n        format = HSL_FORMAT;\r\n    } else {\r\n        format = RGB_FORMAT;\r\n\r\n        ctx.fillStyle = DEFAULT_COLOR;\r\n        ctx.fillStyle = str;\r\n        str = ctx.fillStyle;\r\n        // ColorString is either hex or rgb string,\r\n        // if it's hex convert it to rgb object,\r\n        // if it's rgb then parse it to object.\r\n        if (HEX_REGEX.test(str)) {\r\n            // Convert hex string to rgb object.\r\n            color = {\r\n                r: int(str.slice(1, 3), 16),\r\n                g: int(str.slice(3, 5), 16),\r\n                b: int(str.slice(5, 7), 16),\r\n                a: 1\r\n            }\r\n        } else {\r\n            // Parse rgb string into a rgb object.\r\n            const [r, g, b, a] = /\\((.+)\\)/.exec(str)[1].split(',').map(value => float(value));\r\n            color = { r, g, b, a };\r\n        }\r\n    }\r\n\r\n    // Round the transparency component to two numbers behind\r\n    color.a = round(color.a * 100) / 100;\r\n\r\n    str = stringify(color, format);\r\n\r\n    return asString ? str : [color, format, str];\r\n}","import { caretSVG } from \"../assets/svg\";\r\nimport { COLLAPSE_BUTTON_CLASSNAME, COLLAPSE_CLASSNAME, SWATCHES_CLASSNAME, SWATCH_CLASSNAME } from \"../constants/classnames\";\r\nimport { parseColor } from \"../colors/parser\";\r\nimport { CLICK, COLOR } from \"../constants/globals\";\r\nimport { createButton, createElement, customProperty, removeElement, toggleClassName } from \"../utils/dom\";\r\nimport { int } from \"../utils/number\";\r\nimport { addEvent } from \"../core/events/binder\";\r\nimport { isArray } from \"../utils/object\";\r\n\r\n/**\r\n * Creates color swatches buttons.\r\n *\r\n * @param {Element} ref - Element to append the swatches container to.\r\n * @param {object} alwan - Picker Instance.\r\n * @returns {object} - Swatches component.\r\n */\r\nexport const Swatches = (ref, alwan) => {\r\n\r\n    /**\r\n     * Swatches container.\r\n     *\r\n     * @type {HTMLDivElement | null}\r\n     */\r\n    let container;\r\n\r\n    /**\r\n     * Swatches array.\r\n     *\r\n     * @type {Array<string>}\r\n     */\r\n    let swatchesArray;\r\n\r\n    /**\r\n     * Button.\r\n     *\r\n     * @type {HTMLButtonElement | null}\r\n     */\r\n    let collapseButton;\r\n\r\n    /**\r\n     * Swatches API.\r\n     */\r\n    return {\r\n        /**\r\n         * Creates color swatches.\r\n         *\r\n         * @param {object} param0 - Alwan options.\r\n         * @param {object} instance - Alwan instance.\r\n         */\r\n        _init({ swatches, toggleSwatches }, instance) {\r\n            alwan = instance || alwan;\r\n            swatchesArray = [];\r\n\r\n            if (isArray(swatches)) {\r\n                swatchesArray = swatches;\r\n                container = removeElement(container);\r\n                collapseButton = removeElement(collapseButton);\r\n\r\n                if (swatches.length) {\r\n                    // Create swatches container.\r\n                    container = createElement('', SWATCHES_CLASSNAME, ref);\r\n                    // Create swatch buttons.\r\n                    swatches.forEach(color => {\r\n                        customProperty(\r\n                            createButton(SWATCH_CLASSNAME, container),\r\n                            COLOR,\r\n                            parseColor(color, true)\r\n                        );\r\n                    });\r\n\r\n                    // Create or remove the collapse button depend if the toggleSwatches,\r\n                    // option changes.\r\n                    if (toggleSwatches) {\r\n                        collapseButton = createButton(COLLAPSE_BUTTON_CLASSNAME, ref, { html: caretSVG });\r\n                        /**\r\n                         * Handles toggle swatches button click.\r\n                         */\r\n                        addEvent(collapseButton, CLICK, () => toggleClassName(container, COLLAPSE_CLASSNAME));\r\n                    }\r\n                    /**\r\n                     * Handles clicks in the swatches container.\r\n                     */\r\n                    addEvent(container, CLICK, ({ target }) => {\r\n                        if(target !== container) {\r\n                            alwan._color._set(customProperty(target, COLOR), target, true);\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Adds color swatches.\r\n         *\r\n         * @param {Array<string | object>} swatches - Color swatches array to add.\r\n         */\r\n        _add(swatches) {\r\n            alwan.config.swatches = [ ...swatchesArray, ...swatches ];\r\n            this._init(alwan.config);\r\n        },\r\n\r\n        /**\r\n         * Removes color swatches.\r\n         *\r\n         * @param {Array<string | number | object} swatches - Color swatches or their index to remove.\r\n         */\r\n        _remove(swatches) {\r\n            alwan.config.swatches = swatchesArray.filter((swatch, index) => ! swatches.some((item) => item === swatch || int(item) === index));\r\n            this._init(alwan.config);\r\n        }\r\n    };\r\n}","import { ALWAN_CLASSNAME } from \"../constants/classnames\";\r\nimport { App } from \"../components/App\";\r\nimport { Inputs } from \"../components/Inputs\";\r\nimport { Palette } from \"../components/Palette\";\r\nimport { Sliders } from \"../components/Sliders\";\r\nimport { Swatches } from \"../components/Swatches\";\r\nimport { Utility } from \"../components/Utility\";\r\nimport { bodyElement, createContainer, createElement } from \"../utils/dom\";\r\n\r\n/**\r\n * Shared Components.\r\n */\r\nlet sharedComponents = null;\r\n\r\n/**\r\n * Number of instances that uses the shared components.\r\n */\r\nlet instanceCount = 0;\r\n\r\n/**\r\n * Creates components.\r\n *\r\n * @param {Alwan} alwan - Alwan instance.\r\n * @returns {object} alwan components.\r\n */\r\nconst createComponents = (alwan) => {\r\n\r\n    const root = createElement('', ALWAN_CLASSNAME, bodyElement());\r\n    const _app = App(root, alwan);\r\n    const _palette = Palette(root, alwan);\r\n    const container = createContainer(root);\r\n    const _utility = Utility(container, alwan);\r\n    const _sliders = Sliders(container, alwan);\r\n    const _inputs = Inputs(container, alwan);\r\n    const _swatches = Swatches(root, alwan);\r\n\r\n    return {\r\n        _app,\r\n        _palette,\r\n        _utility,\r\n        _sliders,\r\n        _inputs,\r\n        _swatches\r\n    }\r\n}\r\n\r\n/**\r\n * Checks if components are shared.\r\n *\r\n * @param {object} components - Alwan components.\r\n * @returns {boolean} - True if components are shared.\r\n */\r\nexport const isShared = (components) => {\r\n    return !!sharedComponents && components === sharedComponents;\r\n}\r\n\r\n/**\r\n * Destroys components.\r\n *\r\n * @param {object} components - Alwan components.\r\n * @returns {void}\r\n */\r\nexport const destroyComponents = (components) => {\r\n    if (isShared(components)) {\r\n        instanceCount--;\r\n        if (instanceCount > 0) {\r\n            return;\r\n        }\r\n        sharedComponents = null;\r\n    }\r\n\r\n    components._app._destroy();\r\n    components._palette._destroy();\r\n    components = {};\r\n}\r\n\r\n/**\r\n * Gets components.\r\n *\r\n * @param {Alwan} alwan - Alwan instance.\r\n * @returns {object} components.\r\n */\r\nexport const useComponents = (alwan) => {\r\n    let { _components, config: { shared }} = alwan;\r\n\r\n    // Alwan already has components.\r\n    if (_components) {\r\n        // Nothing is changing, if components are shared and the option shared is true,\r\n        // or the components are not shared and the option shared is false\r\n        // then just return the current components.\r\n        if ((isShared(_components)) === shared) {\r\n            return _components;\r\n        }\r\n\r\n        // Force close the picker before destroying its components.\r\n        _components._app._toggle(alwan, false, true);\r\n        // If something changed, either the components were shared,\r\n        // and the option shared is false which means set the components as,\r\n        // non-shared or the components were non-shared and we want to share them.\r\n        // in either cases we need to destroy the current components.\r\n        destroyComponents(_components);\r\n    }\r\n\r\n    if (shared) {\r\n        // Create components and set them to sharedComponents.\r\n        if (! sharedComponents) {\r\n            sharedComponents = createComponents(alwan);\r\n        }\r\n        // Increase the instances that uses this shared components.\r\n        instanceCount++;\r\n\r\n        return sharedComponents;\r\n    }\r\n\r\n    // Create components.\r\n    return createComponents(alwan);\r\n}","import { BACKDROP_CLASSNAME, MARKER_CLASSNAME, PALETTE_CLASSNAME } from \"../constants/classnames\";\r\nimport { DOC_ELEMENT, KEYBOARD_X, KEYBOARD_Y, KEY_DOWN, POINTER_DOWN, POINTER_MOVE, POINTER_UP, ROOT } from \"../constants/globals\";\r\nimport { addEvent, removeEvent } from \"../core/events/binder\";\r\nimport { createElement, getBounds, translate, removeElement, customProperty } from \"../utils/dom\"\r\nimport { boundNumber, min } from \"../utils/number\";\r\n\r\n/**\r\n * Color picking area, pick color by dragging the marker.\r\n *\r\n * @param {HTMLElement} ref - Insert palette element relative to this element.\r\n * @param {Object} alwan - Alwan instance.\r\n * @returns {Object}\r\n */\r\nexport const Palette = (ref, alwan) => {\r\n    /**\r\n     * Marker X coordinate.\r\n     *\r\n     * @type {number}\r\n     */\r\n    let markerX;\r\n\r\n    /**\r\n     * Marker Y coordinate.\r\n     *\r\n     * @type {number}\r\n     */\r\n    let markerY;\r\n\r\n    /**\r\n     * Palette element bounds.\r\n     *\r\n     * @type {DOMRect}\r\n     */\r\n    let paletteBounds;\r\n\r\n    /**\r\n     * A transparent element that covers the whole document.\r\n     *\r\n     * @type {HTMLDivElement | null}\r\n     */\r\n    let backdropElement;\r\n\r\n    /**\r\n     * Indicates whether a pointer (mouse, pen or touch) is down.\r\n     */\r\n    let isPointerDown = false;\r\n\r\n    /**\r\n     * Palette element.\r\n     */\r\n    const palette = createElement('', PALETTE_CLASSNAME, ref, { tabindex: '0' });\r\n\r\n    /**\r\n     * Palette's marker.\r\n     */\r\n    const marker = createElement('', MARKER_CLASSNAME, palette);\r\n\r\n    /**\r\n     * Moves marker and updates the color state.\r\n     * Moves it using a pointer (mouse, touch or pen) or keyboard arrow keys.\r\n     *\r\n     * @param {PointerEvent | null} e - Pointer Event.\r\n     * @param {object} keyboard - Keyboard steps.\r\n     */\r\n    const moveMarkerAndUpdateColor = (e, keyboard) => {\r\n        let [ x, y, width, height ] = paletteBounds;\r\n        let v, L;\r\n\r\n        if (e) {\r\n            x = e.clientX - x;\r\n            y = e.clientY - y;\r\n        } else {\r\n            x = markerX + keyboard.x * width / 100;\r\n            y = markerY + keyboard.y * height / 100;\r\n        }\r\n\r\n        x = boundNumber(x, width);\r\n        y = boundNumber(y, height);\r\n\r\n        if (x !== markerX || y !== markerY) {\r\n            markerX = x;\r\n            markerY = y;\r\n            translate(marker, markerX, markerY);\r\n\r\n            v = (1 - y / height);\r\n            L = v * (1 - x / (2 * width));\r\n\r\n            alwan._color._update({\r\n                S: L === 1 || L === 0 ? 0 : (v - L) / min(L, 1 - L),\r\n                L\r\n            }, palette);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts dragging the marker.\r\n     *\r\n     * @param {PointerEvent} e - Event.\r\n     */\r\n    const dragStart = e => {\r\n        if (! backdropElement) {\r\n            backdropElement = createElement('', BACKDROP_CLASSNAME, DOC_ELEMENT);\r\n        }\r\n        // Save color state.\r\n        alwan._color._save();\r\n        paletteBounds = getBounds(palette);\r\n        isPointerDown = true;\r\n        moveMarkerAndUpdateColor(e);\r\n    }\r\n\r\n    /**\r\n     * Dragging the marker.\r\n     *\r\n     * @param {PointerEvent} e - Event.\r\n     */\r\n    const drag = e => {\r\n        if (isPointerDown) {\r\n            moveMarkerAndUpdateColor(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Drag end (released the marker).\r\n     *\r\n     * @param {PointerEvent} e - Event.\r\n     */\r\n    const dragEnd = e => {\r\n        if (isPointerDown) {\r\n            alwan._color._change(palette, true);\r\n            backdropElement = removeElement(backdropElement);\r\n            isPointerDown = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Moves marker using keyboard arrow keys and adds focus-visible to the palette.\r\n     *\r\n     * @param {KeyboardEvent} e - Event.\r\n     */\r\n    const handleKeyboard = e => {\r\n        const key = e.key;\r\n        const x = KEYBOARD_X[key] || 0;\r\n        const y = KEYBOARD_Y[key] || 0;\r\n        const core = alwan._color;\r\n\r\n        if (x || y) {\r\n            e.preventDefault();\r\n\r\n            paletteBounds = getBounds(palette);\r\n\r\n            core._save();\r\n            moveMarkerAndUpdateColor(null, { x, y });\r\n            core._change(palette, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Bind events.\r\n     */\r\n    addEvent(palette, POINTER_DOWN, dragStart);\r\n    addEvent(ROOT, POINTER_MOVE, drag);\r\n    addEvent(ROOT, POINTER_UP, dragEnd);\r\n    addEvent(palette, KEY_DOWN, handleKeyboard);\r\n\r\n\r\n    return {\r\n        /**\r\n         * Initialize component.\r\n         *\r\n         * @param {object} options - Alwan options.\r\n         * @param {object} instance - Alwan instance.\r\n         */\r\n        _init(_options, instance) {\r\n            alwan = instance || alwan;\r\n        },\r\n\r\n        /**\r\n         * Updates palette's hue and marker position.\r\n         *\r\n         * @param {object} param0 - Alwan color state object.\r\n         * @param {boolean} updateAll - Whether to update palette (update marker's position).\r\n         */\r\n        _update({ h, S, L }, updateAll) {\r\n            // Update palette's hue.\r\n            customProperty(palette, 'h', h);\r\n\r\n            if (updateAll) {\r\n                paletteBounds = getBounds(palette);\r\n                // Temporary hold the value of V in the HSV color space.\r\n                markerY = L + S * min(L, 1 - L);\r\n\r\n                markerX = (markerY ? 2 * (1 - L / markerY) : 0) * paletteBounds[2];\r\n                markerY = (1 - markerY) * paletteBounds[3];\r\n\r\n                translate(marker, markerX, markerY);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Remove listeners attached to the document.\r\n         */\r\n        _destroy() {\r\n            removeEvent(ROOT, POINTER_MOVE, drag);\r\n            removeEvent(ROOT, POINTER_UP, dragEnd);\r\n        }\r\n    }\r\n}","import { checkSVG, clipboardSVG } from \"../assets/svg\";\r\nimport { COPY_BUTTON_CLASSNAME, PREVIEW_CLASSNAME } from \"../constants/classnames\";\r\nimport { BLUR, CLICK, COLOR, DOC_ELEMENT, INPUT, INSERT_BEFORE_FIRST_CHILD, MOUSE_OUT, ROOT } from \"../constants/globals\";\r\nimport { addEvent } from \"../core/events/binder\";\r\nimport { createButton, createElement, customProperty, removeElement, setHTML } from \"../utils/dom\";\r\n\r\n/**\r\n * Preview color and copy color string.\r\n *\r\n * @param {HTMLElement} ref - Element to insert utility elements into.\r\n * @param {Alwan} alwan - Alwan instance.\r\n * @returns {object} Utility component.\r\n */\r\nexport const Utility = (ref, alwan) => {\r\n    /**\r\n     * Preview color.\r\n     *\r\n     * @type {HTMLDivElement | null}\r\n     */\r\n    let previewElement;\r\n\r\n    /**\r\n     * Copy button.\r\n     *\r\n     * @type {HTMLButtonElement | null}\r\n     */\r\n    let copyButton;\r\n\r\n    /**\r\n     * Indicate whether color is copied.\r\n     */\r\n    let isCopied;\r\n\r\n    /**\r\n     * Set button icon.\r\n     *\r\n     * @param {boolean} state - Copy state.\r\n     */\r\n    const updateIcon = (state) => {\r\n        isCopied = state;\r\n        setHTML(copyButton, state ? checkSVG : clipboardSVG);\r\n    };\r\n\r\n    /**\r\n     * Copy color fallback if browser doesn't support 'navigator.clipboard'.\r\n     *\r\n     * @param {string} color - Color to copy.\r\n     */\r\n    const fallback = (color) => {\r\n        let input = createElement(\r\n            INPUT,\r\n            '',\r\n            DOC_ELEMENT,\r\n            { value: color }\r\n        );\r\n        input.select();\r\n        ROOT.execCommand('copy');\r\n        input = removeElement(input);\r\n        // change icon.\r\n        updateIcon(true);\r\n    };\r\n\r\n    /**\r\n     * Copies the selected color to the clipboard.\r\n     */\r\n    const copyColor = () => {\r\n        if (! isCopied && ! alwan.config.disabled) {\r\n            const clipboard = navigator.clipboard;\r\n            const color = alwan._color._get(true);\r\n\r\n            if (clipboard) {\r\n                clipboard.writeText(color)\r\n                            .then(() => updateIcon(true))\r\n                            .catch(() => fallback(color));\r\n            } else {\r\n                fallback(color);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * API.\r\n     */\r\n    return {\r\n        /**\r\n         * Initialize utility component.\r\n         *\r\n         * @param {object} param0 - Alwan options.\r\n         * @param {object} instance - Alwan instance.\r\n         */\r\n        _init({ preview, copy }, instance) {\r\n            alwan = instance;\r\n\r\n            // Initialize elements.\r\n            previewElement = removeElement(previewElement);\r\n            copyButton = removeElement(copyButton);\r\n\r\n            if (preview) {\r\n                previewElement = createElement('',\r\n                    PREVIEW_CLASSNAME,\r\n                    ref,\r\n                    {},\r\n                    INSERT_BEFORE_FIRST_CHILD\r\n                );\r\n            }\r\n\r\n            if (copy) {\r\n                copyButton = createButton(\r\n                    COPY_BUTTON_CLASSNAME,\r\n                    previewElement || ref,\r\n                    { html: clipboardSVG },\r\n                    INSERT_BEFORE_FIRST_CHILD\r\n                );\r\n\r\n                /**\r\n                 * Add events.\r\n                 */\r\n                addEvent(copyButton, CLICK, copyColor);\r\n                // Reset clipboard icon.\r\n                addEvent(copyButton, BLUR, () => isCopied && updateIcon(false));\r\n                addEvent(copyButton, MOUSE_OUT, () => copyButton.blur());\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Previews current color.\r\n         *\r\n         * @param {string} color - Color string.\r\n         */\r\n        _preview(color) {\r\n            customProperty(previewElement, COLOR, color);\r\n        }\r\n    }\r\n}","import { ALPHA_SLIDER_CLASSNAME, HUE_SLIDER_CLASSNAME, SLIDERS_CLASSNAME } from \"../constants/classnames\";\r\nimport { CHANGE, COLOR, INPUT, RGB_FORMAT } from \"../constants/globals\";\r\nimport { addEvent } from \"../core/events/binder\";\r\nimport { createElement, createSlider, customProperty, removeElement } from \"../utils/dom\";\r\n\r\n/**\r\n * Creates hue and alpha sliders.\r\n *\r\n * @param {HTMLElement} ref - Element to append sliders to.\r\n * @param {Object} alwan - Alwan instance.\r\n * @returns {Object} Sliders component.\r\n */\r\nexport const Sliders = (ref, alwan) => {\r\n    /**\r\n     * Alpha slider.\r\n     *\r\n     * @type {HTMLInputElement | null}\r\n     */\r\n    let alphaSlider;\r\n\r\n    /**\r\n     * Sliders container.\r\n     */\r\n    const container = createElement('', SLIDERS_CLASSNAME, ref);\r\n\r\n    /**\r\n     * Hue slider.\r\n     *\r\n     * @type {HTMLInputElement}\r\n     */\r\n    const hueSlider = createSlider(HUE_SLIDER_CLASSNAME, container, 360);\r\n\r\n    /**\r\n     * Updates color.\r\n     *\r\n     * @param {InputEvent} e - Event.\r\n     */\r\n    const handleChange = ({ target, type, target: { value }}) => {\r\n        if (type === CHANGE) {\r\n            alwan._color._change(target);\r\n        } else {\r\n            alwan._color._update(target === hueSlider ? { h: 360 - value } : { a: value * 1 }, target);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Bind events.\r\n     */\r\n    addEvent(container, INPUT, handleChange);\r\n    addEvent(container, CHANGE, handleChange);\r\n\r\n\r\n    return {\r\n        /**\r\n         * Initialize sliders.\r\n         *\r\n         * @param {object} param0 - Alwan options.\r\n         * @param {object} instance - Alwan instance.\r\n         */\r\n        _init({ opacity }, instance) {\r\n            alwan = instance || alwan;\r\n\r\n            alphaSlider = removeElement(alphaSlider);\r\n\r\n            if (opacity) {\r\n                alphaSlider = createSlider(\r\n                    ALPHA_SLIDER_CLASSNAME,\r\n                    container,\r\n                    1,\r\n                    0.01\r\n                );\r\n            } else {\r\n                alwan._color._update({ a: 1 });\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Sets sliders values and updates alpha slider's background color.\r\n         *\r\n         * @param {object} param0 - Alwan color state object.\r\n         * @param {string} opaqueHex - Hex color without opacity.\r\n         * @param {boolean} updateAll - Whether to update sliders or not.\r\n         */\r\n        _update({ h, a }, opaqueHex, updateAll) {\r\n            // Update alpha slider's background color.\r\n            customProperty(alphaSlider, RGB_FORMAT, opaqueHex);\r\n\r\n            if (updateAll) {\r\n                hueSlider.value = 360 - h;\r\n\r\n                if (alphaSlider) {\r\n                    alphaSlider.value = a;\r\n                }\r\n            }\r\n        }\r\n    };\r\n}","import { switchInputsSVG } from \"../assets/svg\";\r\nimport { INPUTS_CLASSNAME, INPUT_CLASSNAME } from \"../constants/classnames\";\r\nimport { stringify } from \"../colors/stringify\";\r\nimport {\r\n    CHANGE,\r\n    CLICK,\r\n    COLOR,\r\n    COLOR_FORMATS,\r\n    FOCUS_IN,\r\n    HEX_FORMAT,\r\n    INPUT,\r\n    INSERT_AFTER,\r\n    INSERT_BEFORE_FIRST_CHILD,\r\n    KEY_DOWN\r\n} from \"../constants/globals\";\r\nimport { createButton, createContainer, createElement, removeElement } from \"../utils/dom\";\r\nimport { float, max } from \"../utils/number\";\r\nimport { objectIterator } from \"../utils/object\";\r\nimport { addEvent } from \"../core/events/binder\";\r\n\r\n/**\r\n * Creates Inputs.\r\n *\r\n * @param {Element} ref - Insert outer container relative to this element.\r\n * @param {Object} alwan - Alwan instance.\r\n * @returns {Object} - Inputs component.\r\n */\r\nexport const Inputs = (ref, alwan) => {\r\n\r\n    /**\r\n     * Outer container.\r\n     *\r\n     * @type {HTMLDivElement | null}\r\n     */\r\n    let container;\r\n\r\n    /**\r\n     * Inputs wrapper.\r\n     *\r\n     * @type {HTMLDivElement | null}\r\n     */\r\n    let inputsContainer;\r\n\r\n    /**\r\n     * Switch button.\r\n     *\r\n     * @type {HTMLButtonElement | null}\r\n     */\r\n    let switchButton;\r\n\r\n    /**\r\n     * Inputs color formats.\r\n     */\r\n    let formats = [];\r\n\r\n    /**\r\n     * Current color format index.\r\n     *\r\n     * @type {number}\r\n     */\r\n    let currentFormatIndex;\r\n\r\n    /**\r\n     * Object that maps fields label to their inputs.\r\n     *\r\n     * @type {object}\r\n     */\r\n    let inputsMap;\r\n\r\n    /**\r\n     * Indicates that an input value has changed.\r\n     */\r\n    let isChanged = false;\r\n\r\n    /**\r\n     * Checks if inputs are one single input.\r\n     */\r\n    const isSingle = () => {\r\n        return alwan.config.singleInput || formats[currentFormatIndex] === HEX_FORMAT;\r\n    };\r\n\r\n    /**\r\n     * Builds inputs.\r\n     */\r\n    const build = () => {\r\n        // Initialize inputs map.\r\n        inputsMap = {};\r\n        // Create inputs container.\r\n        removeElement(inputsContainer);\r\n        inputsContainer = createElement('', INPUTS_CLASSNAME, container, {}, INSERT_BEFORE_FIRST_CHILD);\r\n\r\n        const color = alwan._color._get();\r\n        // Each letter in the format variable represent a color channel,\r\n        // For multiple inputs, each color channel has an input field.\r\n        // e.g. for 'rgb' format fields array is [r, g, b] or [r, g, b, a] if opacity is true.\r\n        const format = formats[currentFormatIndex];\r\n        const fields = isSingle()\r\n            ? [format]\r\n            : (format + (alwan.config.opacity ? 'a' : '')).split('');\r\n\r\n        fields.forEach(field => {\r\n            /**\r\n             * Create Input.\r\n             *\r\n             * <label>\r\n             *     <input type=\"text\" class=\"alwan__input\">\r\n             *     <span>${field}</span>\r\n             * </label>\r\n             */\r\n            const labelElement = createElement('label', '', inputsContainer);\r\n            inputsMap[field] = createElement(INPUT, INPUT_CLASSNAME, labelElement, { type: 'text', value: color[field] + '' });\r\n            createElement('span', '', labelElement, { html: field });\r\n        });\r\n\r\n        /**\r\n        * Bind events.\r\n        */\r\n        addEvent(inputsContainer, INPUT, handleChange);\r\n        addEvent(inputsContainer, CHANGE, handleChange);\r\n        // Select value on focus.\r\n        addEvent(inputsContainer, FOCUS_IN, (e) => { e.target.select(); });\r\n        // Close picker if enter pressed while focusing in inputs.\r\n        addEvent(inputsContainer, KEY_DOWN, (e) => { e.key === 'Enter' && alwan.close() });\r\n    }\r\n\r\n    /**\r\n     * Changes color format.\r\n     */\r\n    const changeFormat = () => {\r\n        // Increment input format index, reset it if it reaches the end.\r\n        // this index will point to the next format.\r\n        currentFormatIndex = (currentFormatIndex + 1) % formats.length;\r\n        alwan._color._setFormat(formats[currentFormatIndex]);\r\n        build();\r\n    }\r\n\r\n    /**\r\n     * Handles changes in inputs.\r\n     *\r\n     * @param {InputEvent} e - Event.\r\n     */\r\n    const handleChange = ({ target, type }) => {\r\n\r\n        if (type === CHANGE) {\r\n            alwan._color._change(target, true);\r\n            isChanged = false;\r\n        } else {\r\n\r\n            if (! isChanged) {\r\n                alwan._color._save();\r\n                isChanged = true;\r\n            }\r\n\r\n            let str = target.value;\r\n            let color = {};\r\n\r\n            if (! isSingle()) {\r\n                // Copy inputs values into an object (rgb or hsl).\r\n                objectIterator(inputsMap, (input, key) => {\r\n                    color[key] = float(input.value);\r\n                });\r\n                // Convert the object into string.\r\n                str = stringify(color, formats[currentFormatIndex]);\r\n            }\r\n\r\n            alwan._color._set(str, target);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Component API.\r\n     */\r\n    return {\r\n        /**\r\n         * Initialize Inputs.\r\n         *\r\n         * @param {object} param0 - Alwan options.\r\n         * @param {object} instance - Alwan instance.\r\n         */\r\n        _init({ inputs, format }, instance) {\r\n            alwan = instance || alwan;\r\n            inputs = inputs || {};\r\n\r\n            formats = COLOR_FORMATS;\r\n\r\n            if (inputs !== true) {\r\n                // Get only valid formats.\r\n                formats = formats.filter((format) => inputs[format]);\r\n            }\r\n\r\n            const length = formats.length;\r\n\r\n            // Validate format.\r\n            if(! length) {\r\n                formats = COLOR_FORMATS;\r\n            }\r\n            currentFormatIndex = max(formats.indexOf(format), 0);\r\n            alwan._color._setFormat(formats[currentFormatIndex]);\r\n\r\n            // Initialize element.\r\n            container = removeElement(container);\r\n            switchButton = removeElement(switchButton);\r\n\r\n            if (length) {\r\n                // Create container and insert it after the util-sliders container.\r\n                container = createContainer(ref, INSERT_AFTER);\r\n                build();\r\n\r\n                if (length > 1) {\r\n                    switchButton = createButton('', container, { html: switchInputsSVG });\r\n                    addEvent(switchButton, CLICK, changeFormat);\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Updates Input(s) value(s).\r\n         *\r\n         * @param {Object} color - Alwan color state object.\r\n         */\r\n        _values(color) {\r\n            if (! isChanged) {\r\n                objectIterator(inputsMap || {}, (input, key) => {\r\n                    input.value = color[key];\r\n                })\r\n            }\r\n        }\r\n    }\r\n}","import { abs, max, min, normalizeAngle, round } from \"../utils/number\";\r\n\r\n/**\r\n * Converts a decimal number to hexadecimal.\r\n *\r\n * @param {number} number - A decimal number.\r\n */\r\nconst toHex = (number) => {\r\n    return (number < 16 ? '0' : '') + number.toString(16);\r\n};\r\n\r\n/**\r\n * Converts RGB color to hex.\r\n *\r\n * returns an array of two values, the hex string without the alpha channel,\r\n * and the alpha channel (in hexadecimal).\r\n *\r\n * The hex without alpha (opaque) is used to color the background of the alpha slider.\r\n *\r\n * @param {object} param0 - RGB color object.\r\n */\r\nexport const RGBToHEX = ({ r, g, b, a }) => {\r\n    return ['#' + toHex(r) + toHex(g) + toHex(b), a < 1 ? toHex(round(a * 255)) : ''];\r\n};\r\n\r\n/**\r\n * Helper function used for converting HSL to RGB.\r\n *\r\n * @param {number} k - Positive coefficient.\r\n * @param {number} s - HSL saturation.\r\n * @param {number} l - HSL lightness.\r\n */\r\nexport const fn = (k, s, l) => {\r\n    k %= 12;\r\n    return round((l - s * min(l, 1 - l) * max(-1, min(k - 3, 9 - k, 1))) * 255);\r\n};\r\n\r\n/**\r\n * Converts HSL to RGB.\r\n *\r\n * @param {object} param0 - HSL color components.\r\n */\r\nexport const HSLToRGB = ({ h, S, L }) => {\r\n    h /= 30;\r\n    return {\r\n        r: fn(h, S, L),\r\n        g: fn(h + 8, S, L),\r\n        b: fn(h + 4, S, L),\r\n    };\r\n};\r\n\r\n/**\r\n * Converts RGB to HSL.\r\n *\r\n * @param {object} param0 - RGB color object.\r\n * @returns {object} - HSL color object.\r\n */\r\nexport const RGBToHSL = ({ r, g, b, a }) => {\r\n    r /= 255;\r\n    g /= 255;\r\n    b /= 255;\r\n\r\n    const cMax = max(r, g, b);\r\n    const cMin = min(r, g, b);\r\n    const d = cMax - cMin;\r\n    const L = (cMax + cMin) / 2;\r\n    const h =\r\n        d === 0\r\n            ? 0\r\n            : cMax === r\r\n            ? ((g - b) / d) % 6\r\n            : cMax === g\r\n            ? (b - r) / d + 2\r\n            : cMax === b\r\n            ? (r - g) / d + 4\r\n            : 0;\r\n\r\n    return {\r\n        h: normalizeAngle(h * 60),\r\n        S: d ? d / (1 - abs(2 * L - 1)) : 0,\r\n        L,\r\n        a,\r\n    };\r\n};","import { HSLToRGB, RGBToHEX, RGBToHSL } from \"../colors/converter\";\r\nimport { parseColor } from \"../colors/parser\";\r\nimport { stringify } from \"../colors/stringify\";\r\nimport { CHANGE, COLOR, HSL_FORMAT, RGB_FORMAT } from \"../constants/globals\";\r\nimport { customProperty } from \"../utils/dom\";\r\nimport { round } from \"../utils/number.js\";\r\nimport { keys, merge } from \"../utils/object\";\r\n\r\n/**\r\n * Creates the core color state and UI updater.\r\n *\r\n * @param {object} alwan - Alwan instance.\r\n * @returns {object} Core color state.\r\n */\r\nexport const color = (alwan) => {\r\n\r\n    /**\r\n     * Save an rgb string.\r\n     *\r\n     * @type {string}\r\n     */\r\n    let savedColor;\r\n\r\n    /**\r\n     * Current color format.\r\n     *\r\n     * @type {'rgb'|'hsl'|'hex'}\r\n     */\r\n    let format;\r\n\r\n    /**\r\n     * Color state.\r\n     */\r\n    const state = {\r\n        // Hue.\r\n        h: 0,\r\n        // Saturation (capital S) and Lightness (capital L),\r\n        // are used internally, their values are between 0-1.\r\n        S: 0,\r\n        L: 0,\r\n\r\n        // HSL saturation and lightness (0-100)\r\n        s: 0,\r\n        l: 0,\r\n\r\n        // Red, Green and Blue values (0-255)\r\n        r: 0,\r\n        g: 0,\r\n        b: 0,\r\n\r\n        // Opacity value (0-1)\r\n        a: 1,\r\n\r\n        // color strings.\r\n        rgb: '',\r\n        hex: '',\r\n        hsl: ''\r\n    }\r\n\r\n    /**\r\n     * Alwan options.\r\n     */\r\n    const config = alwan.config;\r\n\r\n    return {\r\n        /**\r\n         * Updates color state and UI.\r\n         *\r\n         * @param {object} hsl - HSL color components.\r\n         * @param {HTMLElement | undefined} source - Element that updating the color.\r\n         * @param {boolean | undefined} updateAll - Whether to update the palette and sliders components.\r\n         * @param {object | undefined} rgb - RGB color object.\r\n         */\r\n        _update(hsl, source, updateAll = false, rgb) {\r\n            if (! config.disabled) {\r\n\r\n                const { r, g, b, a } = state;\r\n\r\n                merge(state, hsl);\r\n                merge(\r\n                    state,\r\n                    {\r\n                        s: round(state.S * 100),\r\n                        l: round(state.L * 100),\r\n                    },\r\n                    rgb || HSLToRGB(state)\r\n                );\r\n\r\n                const { _inputs, _palette, _sliders, _utility } = alwan._components;\r\n                const rgbString = stringify(state, RGB_FORMAT);\r\n                const [opaqueHex, alphaHex] = RGBToHEX(state);\r\n\r\n                state.hsl = stringify(state, HSL_FORMAT);\r\n                state.hex = opaqueHex + alphaHex;\r\n                state.rgb = rgbString;\r\n\r\n                // Update ui.\r\n                customProperty(alwan._reference._el(), COLOR, rgbString);\r\n                _palette._update(state, updateAll);\r\n                _utility._preview(rgbString);\r\n                _sliders._update(state, opaqueHex, updateAll);\r\n                _inputs._values(state);\r\n\r\n                // If an element in the picker is changing the state,\r\n                // then trigger color event.\r\n                if (source && (state.r !== r || state.g !== g || state.b !== b || state.a !== a)) {\r\n                    alwan._events._dispatch(COLOR, source);\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Saves the current color as a string.\r\n         */\r\n        _save() {\r\n            savedColor = state[format];\r\n        },\r\n\r\n        /**\r\n         * Triggers change event.\r\n         *\r\n         * If checkChange flag is true, fire change event only if the saved color (color start),\r\n         * and the current color are different.\r\n         *\r\n         * @param {HTMLElement} source - Event source.\r\n         * @param {boolean} check - Whether to compare current color with the saved color.\r\n         */\r\n        _change(source, check) {\r\n            if (!check || (check && savedColor !== state[format])) {\r\n                alwan._events._dispatch(CHANGE, source);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Sets a new color.\r\n         *\r\n         * @param {string|object} color - Color string or object.\r\n         * @param {HTMLElement | undefined} source - Source element.\r\n         * @param {boolean} triggerChange - Whether to fire the change event or not.\r\n         */\r\n        _set(color, source, triggerChange) {\r\n            let [parsedColor, parsedColorFormat, parsedColorString] = parseColor(color);\r\n            let rgb, hsl;\r\n\r\n            // Update color state if the current color and the parsed color are different.\r\n            if (state[parsedColorFormat] !== parsedColorString) {\r\n                if (parsedColorFormat === RGB_FORMAT) {\r\n                    rgb = parsedColor;\r\n                    hsl = RGBToHSL(rgb);\r\n                } else {\r\n                    hsl = parsedColor;\r\n                    hsl.S = parsedColor.s / 100;\r\n                    hsl.L = parsedColor.l / 100;\r\n                }\r\n\r\n                this._update(hsl, source, true, rgb);\r\n\r\n                if (triggerChange) {\r\n                    this._change(source);\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Creates and return color value.\r\n         *\r\n         * @returns {object} - Color value.\r\n         */\r\n        _value: () => ({\r\n            h: state.h,\r\n            s: state.s,\r\n            l: state.l,\r\n\r\n            r: state.r,\r\n            g: state.g,\r\n            b: state.b,\r\n\r\n            a: state.a,\r\n\r\n            hex: state.hex,\r\n            rgb: state.rgb,\r\n            hsl: state.hsl\r\n        }),\r\n\r\n        /**\r\n         * Sets a new color format.\r\n         *\r\n         * @param {string} newFormat - Color format.\r\n         */\r\n        _setFormat(newFormat) {\r\n            format = config.format = newFormat;\r\n        },\r\n\r\n        /**\r\n         * Gets color state object or current color as a string\r\n         *\r\n         * @returns {string | object}\r\n         */\r\n        _get: (asString) => asString ? state[format] : state,\r\n    }\r\n}","import { DEFAULT_COLOR } from \"./globals\";\r\n\r\n/**\r\n * Alwan defaults.\r\n */\r\n export const defaults = {\r\n    /**\r\n     * Set the container's (widget) id.\r\n     *\r\n     * @type {string}\r\n     */\r\n    id: '',\r\n\r\n    /**\r\n     * Add classes (separated by a white space) to the preset button.\r\n     *\r\n     * @type {string}\r\n     */\r\n    classname: '',\r\n\r\n    /**\r\n     * Choose a theme.\r\n     *\r\n     * @type {'dark' | 'light'}\r\n     */\r\n    theme: 'light',\r\n\r\n    /**\r\n     * Toggle picker's visibility (Show/Hide), Setting this to false keeps the picker visible.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    toggle: true,\r\n\r\n    /**\r\n     * Display the picker container as a pop-up (a box that floats on top of the page content),\r\n     * if it's false, picker container will be displayed as a block (embedded in the page's content).\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    popover: true,\r\n\r\n    /**\r\n     * Set the position of the popper (if popover is set to true) relative to the reference element,\r\n     * the position has two values separated by a dash (-),\r\n     * the first value is the direction (top, bottom, right, left),\r\n     * the second value is the alignment (start, center, end), omitting this value will default to center.\r\n     * e.g. 'bottom-start': 'bottom' places the picker below the reference element,\r\n     * and 'start' aligns the left side of the container with the left side of the reference element.\r\n     * Note:\r\n     * If the picker container has no space to be placed, it will auto-position itself.\r\n     * based on the available space.\r\n     *\r\n     * @type {string}\r\n     */\r\n    position: 'bottom-start',\r\n\r\n    /**\r\n     * Set the gap (in pixels) between the picker container and the reference element.\r\n     *\r\n     * @type {number}\r\n     */\r\n    margin: 0,\r\n\r\n    /**\r\n     * Replace the reference element with a pre-styled button.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    preset: true,\r\n\r\n    /**\r\n     * Initial color.\r\n     *\r\n     * @type {string | object}\r\n     */\r\n    color: DEFAULT_COLOR,\r\n\r\n    /**\r\n     * Default color.\r\n     *\r\n     * @type {string | object}\r\n     */\r\n    default: DEFAULT_COLOR,\r\n\r\n    /**\r\n     * Target can be a selector or an HTML element,\r\n     * If the option popover is true, the picker container will be positioned relative to this element,\r\n     * instead of the reference element.\r\n     * else if popover option is false, the picker container will be appended as a child into this element.\r\n     *\r\n     * @type {string | Element}\r\n     */\r\n    target: '',\r\n\r\n    /**\r\n     * Disable the picker, users won't be able to pick colors.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    disabled: false,\r\n\r\n    /**\r\n     * Initial color format.\r\n     *\r\n     * @type {string}\r\n     */\r\n    format: 'rgb',\r\n\r\n    /**\r\n     * For the formats 'hsl' and 'rgb', choose a single input to display the color string,\r\n     * or if false, display an input for each color channel.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    singleInput: false,\r\n\r\n    /**\r\n     * Input(s) field(s) for each color format. if this option is set to true then all formats are,\r\n     * selected.\r\n     *\r\n     * @type {boolean | object}\r\n     */\r\n    inputs: {\r\n        rgb: true,\r\n        hex: true,\r\n        hsl: true,\r\n    },\r\n\r\n   /**\r\n    * Support alpha channel and display opacity slider.\r\n    *\r\n    * @type {boolean}\r\n    */\r\n    opacity: true,\r\n\r\n    /**\r\n     * Preview the color.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    preview: true,\r\n\r\n    /**\r\n     * Add/Remove a copy button.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    copy: true,\r\n\r\n    /**\r\n     * Array of color swatches, invalid values will default to the DEFAULT_COLOR.\r\n     *\r\n     * @type {Array<string | object>}\r\n     */\r\n    swatches: [],\r\n\r\n    /**\r\n     * Share components with multiple alwan instances (use less memory if there\r\n     * are multiple color picker instances).\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    shared: false,\r\n\r\n    /**\r\n     * Make swatches container collapsible.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    toggleSwatches: false,\r\n\r\n    /**\r\n     * Close color picker when scrolling, only if the color picker,\r\n     * is displayed as a popover and can be closed.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    closeOnScroll: false,\r\n}","import { Reference } from \"./components/reference\";\r\nimport { merge, objectIterator, prototype, setPrototypeOf } from \"./utils/object\";\r\nimport { destroyComponents, isShared, useComponents } from \"./core/component\";\r\nimport { color } from \"./core/color\";\r\nimport { Dispatcher } from \"./core/events/dispatcher\";\r\nimport \"./assets/scss/alwan.scss\";\r\nimport { defaults } from \"./constants/defaults\";\r\nimport { isset } from \"./utils/is\";\r\nimport { getElement } from \"./utils/dom\";\r\n\r\n\r\nexport default class Alwan {\r\n\r\n    static version = VERSION;\r\n\r\n    /**\r\n     * Alwan defaults.\r\n     */\r\n    static defaults = defaults;\r\n\r\n    /**\r\n     * Alwan instance constructor.\r\n     *\r\n     * @param {String|Element} reference - The reference element.\r\n     * @param {Object} options - Options.\r\n     */\r\n    constructor(reference, options) {\r\n        const alwan = this;\r\n\r\n        alwan.config = merge({}, Alwan.defaults);\r\n        alwan._events = Dispatcher(alwan);\r\n        alwan._color = color(alwan);\r\n        alwan._reference = Reference(getElement(reference), alwan);\r\n        alwan.setOptions(options);\r\n    }\r\n\r\n    /**\r\n     * Sets new options.\r\n     *\r\n     * @param {Object} options - Alwan options.\r\n     */\r\n    setOptions(options) {\r\n        options = options || {};\r\n\r\n        let alwan = this;\r\n        let config = alwan.config;\r\n        let { color, disabled } = options;\r\n        let core = alwan._color;\r\n        let components, app;\r\n\r\n        alwan._reference._setDisabled(disabled);\r\n\r\n        if (! config.disabled) {\r\n            merge(config, options);\r\n            alwan._components = components = useComponents(alwan);\r\n            alwan._reference._init(config);\r\n            app = components._app;\r\n\r\n            if (isShared(components)) {\r\n                app._toggle(null, false);\r\n            }\r\n\r\n            app._setup(config, alwan);\r\n\r\n            if (isset(color)) {\r\n                core._set(color);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the state of the picker whether it's opened or closed.\r\n     *\r\n     * @returns {Boolean}\r\n     */\r\n    isOpen() {\r\n        return this._components._app._isOpen();\r\n    }\r\n\r\n    /**\r\n     * Opens the picker.\r\n     */\r\n    open() {\r\n        this._components._app._toggle(this, true);\r\n    }\r\n\r\n    /**\r\n     * Closes the picker.\r\n     */\r\n    close() {\r\n        this._components._app._toggle(this, false);\r\n    }\r\n\r\n    /**\r\n     * Toggles (opens/closes) the picker.\r\n     */\r\n    toggle() {\r\n        this._components._app._toggle(this);\r\n    }\r\n\r\n    /**\r\n     * Attaches an event handler function for an event.\r\n     *\r\n     * @param {String} type - Event type.\r\n     * @param {CallableFunction} handler - Event handler.\r\n     */\r\n    on(type, handler) {\r\n        this._events._addListener(type, handler);\r\n    }\r\n\r\n    /**\r\n     * Detaches one or more event handlers.\r\n     *\r\n     * Note:\r\n     * omitting handler, remove all handlers from the event,\r\n     * omitting both event type and handler, remove all handlers that are,\r\n     * attached to all events.\r\n     *\r\n     * @param {String} type - Event type.\r\n     * @param {CallableFunction} handler - Event handler.\r\n     */\r\n    off(type, handler) {\r\n        this._events._removeListeners(type, handler);\r\n    }\r\n\r\n    /**\r\n     * Sets a color.\r\n     *\r\n     * @param {String|Object} color - Color.\r\n     */\r\n    setColor(color) {\r\n        this._color._set(color);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets color.\r\n     *\r\n     * @returns {Object}\r\n     */\r\n    getColor() {\r\n        return this._color._value();\r\n    }\r\n\r\n    /**\r\n     * Adds color swatches.\r\n     *\r\n     * @param {Array<string | object>} swatches - Color swatches.\r\n     */\r\n    addSwatches(...swatches) {\r\n        this._components._swatches._add(swatches);\r\n    }\r\n\r\n    /**\r\n     * Removes color swatches.\r\n     *\r\n     * @param {Array<string | number | object} swatches - Array of swatches or their indexes in the config.swatches array.\r\n     */\r\n    removeSwatches(...swatches) {\r\n        this._components._swatches._remove(swatches);\r\n    }\r\n\r\n    /**\r\n     * Enables picker.\r\n     */\r\n    enable() {\r\n        this._reference._setDisabled(false);\r\n    }\r\n\r\n    /**\r\n     * Disables picker.\r\n     */\r\n    disable() {\r\n        this._reference._setDisabled(true);\r\n    }\r\n\r\n    /**\r\n     * Resets to default color.\r\n     */\r\n    reset() {\r\n        this._color._set(this.config.default);\r\n    }\r\n\r\n    /**\r\n     * Repositions picker if it's displayed as a popover.\r\n     */\r\n    reposition() {\r\n        this._components._app._reposition();\r\n    }\r\n\r\n    /**\r\n     * Executes all handlers attached to the specified event.\r\n     *\r\n     * @param {String} type - Event type.\r\n     */\r\n    trigger(type) {\r\n        this._events._dispatch(type);\r\n    }\r\n\r\n    /**\r\n     * Destroy picker and free up memory.\r\n     */\r\n    destroy() {\r\n        const alwan = this;\r\n\r\n        alwan._reference._destroy();\r\n        destroyComponents(alwan._components);\r\n\r\n        // Remove all properties of this instance.\r\n        objectIterator(alwan, (_, key) => {\r\n            delete alwan[key];\r\n        });\r\n\r\n        // Empty instance prototype.\r\n        setPrototypeOf(alwan, prototype);\r\n    }\r\n}","import { CHANGE, CLOSE, COLOR, OPEN } from \"../../constants/globals\"\r\nimport { merge, objectIterator } from \"../../utils/object\";\r\nimport { isset } from \"../../utils/is\";\r\n\r\n/**\r\n * Alwan events.\r\n *\r\n * @param {Alwan} alwan - Alwan Instance.\r\n * @returns\r\n */\r\nexport const Dispatcher = (alwan) => {\r\n    /**\r\n     * Alwan event listeners.\r\n     */\r\n    const listeners = {\r\n        [OPEN]: [],\r\n        [CLOSE]: [],\r\n        [CHANGE]: [],\r\n        [COLOR]: []\r\n    }\r\n\r\n    return {\r\n        /**\r\n         * Dispatch an event.\r\n         *\r\n         * @param {string} type - Alwan event.\r\n         * @param {object} ev - Event object.\r\n         */\r\n        _dispatch(type, source) {\r\n            if (! alwan.config.disabled) {\r\n                (listeners[type] || []).forEach(handler => {\r\n                    handler(merge({ type, source }, alwan._color._value()));\r\n                });\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Add an event listener.\r\n         *\r\n         * @param {string} event - Alwan event.\r\n         * @param {Function} listener - Event listener callback.\r\n         */\r\n        _addListener(event, listener) {\r\n            if (listeners[event] && ! listeners[event].includes(listener)) {\r\n                listeners[event].push(listener);\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Remove event listener(s).\r\n         *\r\n         * @param {string} event - Alwan event.\r\n         * @param {Function} listener - Event listener callback.\r\n         */\r\n        _removeListeners(event, listener) {\r\n            if (! isset(event)) {\r\n                // Remove all listeners if event is undefined.\r\n                objectIterator(listeners, (_array, alwanEvent) => {\r\n                    listeners[alwanEvent] = [];\r\n                });\r\n            } else if (listeners[event]) {\r\n                if (isset(listener)) {\r\n                    // Remove the given listener.\r\n                    listeners[event] = listeners[event].filter((fn) => fn !== listener);\r\n                } else {\r\n                    // Remove all listeners of a given event if listener is undefined.\r\n                    listeners[event] = [];\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","ALWAN_CLASSNAME","CONTAINER_CLASSNAME","PALETTE_CLASSNAME","MARKER_CLASSNAME","PREVIEW_CLASSNAME","BUTTON_CLASSNAME","COPY_BUTTON_CLASSNAME","SLIDER_CLASSNAME","SLIDERS_CLASSNAME","HUE_SLIDER_CLASSNAME","ALPHA_SLIDER_CLASSNAME","INPUT_CLASSNAME","INPUTS_CLASSNAME","SWATCH_CLASSNAME","SWATCHES_CLASSNAME","PRESET_BUTTON_CLASSNAME","BACKDROP_CLASSNAME","COLLAPSE_BUTTON_CLASSNAME","POPUP_CLASSNAME","OPEN_CLASSNAME","COLLAPSE_CLASSNAME","ROOT","document","DOC_ELEMENT","documentElement","DEFAULT_COLOR","BUTTON","OPEN","CLOSE","COLOR","CLICK","POINTER_DOWN","POINTER_MOVE","POINTER_UP","KEY_DOWN","INPUT","CHANGE","RGB_FORMAT","HSL_FORMAT","COLOR_FORMATS","INSERT_BEFORE_FIRST_CHILD","INSERT_AFTER","INSERT_AFTER_LAST_CHILD","KEYBOARD_X","ArrowRight","ArrowLeft","KEYBOARD_Y","ArrowDown","ArrowUp","addEvent","target","event","listener","addEventListener","removeEvent","removeEventListener","keys","assign","merge","setPrototypeOf","from","toArray","isArray","Array","objectIterator","object","fn","props","isString","value","isset","isTogglable","shared","toggle","bodyElement","body","getElement","reference","context","all","trim","Element","contains","insertElement","element","targetElement","where","insertAdjacentElement","setHTML","html","innerHTML","createElement","tagName","className","details","insertPosition","name","setAttribute","getBounds","x","y","width","height","right","bottom","clientWidth","clientHeight","getBoundingClientRect","replaceElement","replacement","replaceWith","removeElement","remove","getOverflowAncestors","ancestors","parentElement","test","getComputedStyle","overflow","push","customProperty","property","style","toggleClassName","tokens","toggler","forEach","token","classList","createButton","type","translate","transform","createSlider","parent","max","step","createContainer","Reference","userReference","alwan","buttonClasses","handleClick","_el","_init","preset","classname","id","split","_setDisabled","disabled","config","_components","_app","_toggle","_destroy","this","parseFloat","float","parseInt","int","isFinite","isNumeric","Number","min","abs","round","PI","Math","boundNumber","number","upperBound","lowerBound","normalizeAngle","angle","fallbackSides","top","left","fallbackAlignments","start","center","end","App","popoverInstance","isOpen","_setup","options","instance","components","theme","popover","position","margin","refElement","_reference","isShared","dataset","display","container","_margin","_position","autoUpdate","popoverAccessibility","side","alignment","sidesFlipOrder","alignmentsFlipOrder","overflowAncestors","_update","visualViewport","targetBounds","containerBounds","coordinates","some","axis","domSide","targetSide","requiredSpace","containerDimension","targetLowerBound","targetUpperBound","upperBoundDistance","offset","map","isVisible","every","ancestor","ancestorX","ancestorY","ancestorRight","ancestorBottom","eventHandler","popoverEvents","window","createPopover","_color","update","isInViewport","closeOnScroll","e","focusableElements","firstFocusableElement","lastFocusableElement","elementToFocusOn","shiftKey","labels","label","pop","preventDefault","focus","state","forced","instanceConfig","_reposition","_events","_dispatch","_isOpen","clipboardSVG","stringify","color","format","opacity","a","str","r","g","b","h","s","l","ctx","getContext","HSL_REGEX","HEX_REGEX","ANGLE_COEFFICIENT_MAP","deg","turn","rad","grad","parseColor","asString","find","input","percentage","exec","fillStyle","slice","Swatches","ref","swatchesArray","collapseButton","swatches","toggleSwatches","length","_set","_add","_remove","filter","swatch","index","item","sharedComponents","instanceCount","createComponents","_palette","markerX","markerY","paletteBounds","backdropElement","isPointerDown","palette","tabindex","marker","moveMarkerAndUpdateColor","keyboard","v","L","clientX","clientY","S","drag","dragEnd","_change","_save","core","_options","updateAll","Palette","_utility","previewElement","copyButton","isCopied","updateIcon","fallback","select","execCommand","copyColor","clipboard","navigator","_get","writeText","then","catch","preview","copy","blur","_preview","Utility","_sliders","alphaSlider","hueSlider","handleChange","opaqueHex","Sliders","_inputs","inputsContainer","switchButton","currentFormatIndex","inputsMap","formats","isChanged","isSingle","singleInput","build","field","labelElement","close","changeFormat","_setFormat","inputs","indexOf","_values","Inputs","_swatches","destroyComponents","toHex","toString","k","savedColor","rgb","hex","hsl","source","HSLToRGB","rgbString","alphaHex","RGBToHEX","check","triggerChange","parsedColor","parsedColorFormat","parsedColorString","cMax","cMin","d","RGBToHSL","_value","newFormat","defaults","default","Alwan","VERSION","constructor","listeners","handler","_addListener","includes","_removeListeners","_array","alwanEvent","Dispatcher","setOptions","app","useComponents","open","on","off","setColor","getColor","addSwatches","removeSwatches","enable","disable","reset","reposition","trigger","destroy","_"],"sourceRoot":""}